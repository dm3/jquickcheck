Providing a custom junit runner is mandatory as all of the @Test methods are
validated for being no-arg public void methods.
There is no way to test the test runner by using something like

    public class QuickCheckRunnerTest {
        @RunWith(QuickCheckRunner.class)
        public static class SimpleTest {
            @Test
            public void shouldRunTheTestWithNoArguments() {
                Assert.assertTrue(true);
            }
        }

        @Test
        public void runSimpleTest() throws InitializationError {
            Result result = JUnitCore.runClasses(SimpleTest.class);

            Assert.assertEquals(result.getFailureCount(), 0);
            Assert.assertEquals(result.getRunCount(), 1);
        }
    }

As the `Result` object returned by `JUnitCore` only knows if our runner has
been passed the test method, but not if it has actually invoked it.

    JUnitCore.runClasses(Test.class);

Is a shortcut for creating a runner and invoking it with a custom `RunNotifier`
containing a possibly custom `RunListener`.

## Dispatching on primitive types
To tell if a `java.lang.reflect.Type` (usually an instance of
`java.lang.Class`) represents a primitive, you need to compare it with a
special static `TYPE` variable on the respective primitive wrapper class
(`Double.TYPE`, ...).

## Features DONE
1. Generator instances in @Before and @BeforeClass blocks
    - Generators cannot be initialized in Before blocks in JUnit as Befores are
      applied to the Statement after it's generated by jcheck. This isn't
      impossible, just requires more work.
2. Generator API - what we have in fj-test currently won't work as it's not really extensible
    * Use quickcheck from quickcheck.java.net
    * Ideally specifying generators should look like this:

    @Arb
    Generator<Integer> sizedInt = of(integer(), from(1), to(10))

    @Arb
    Generator<List<String>> listOfStrings = list(of(string(), alphanumeric()))

This feature won't be implemented as jcheck relies on FJ/javaNetQuickCheck generators.

## Features TODO
3. Dependencies between tests (ala JExample/jBehave/TestNG)
4. Automatic generator resolution according to types. Sensible defaults and generator registry.
5. Separate the project into 5 submodules:
    - JUnit
    - TestNG
    - FJ
    - java.net.QuickCheck
    - core
6. Add default generator resolution strategy discovery
7. FJ - allow both Gen and Arbitrary as generators?
8. Additional custom generator type resolution algorithms for javaNetQuickCheck and FJ (based on method return type?)
9. Integration with templates (makeiteasy):
    - FJ: Some code generation will probably be needed to generate the Gen for the result of the template.
          All of the properties registered with `with` will have to be associated to some static registry and later,
          when the test method is executed, will be bound (`Gen#bind`) to produce the `Gen<Result>`.
10. Test project which will use quickcheck and codemodel to generate test classes and feed them back into jquickcheck.
    Wanted to use codemodel at first, but found out it's GPL'd. This wouldn't
    cause much trouble as it would only be used for testing purposes (no
    linking with codemodel in the released jars) but it would make the
    `jquickcheck-test` project GPL which doesn't really suit me.
