package lt.dm3.jquickcheck.api.impl;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import lt.dm3.jquickcheck.api.QuickCheckException;
import lt.dm3.jquickcheck.api.Synthesizer;
import lt.dm3.jquickcheck.internal.Arrays;
import lt.dm3.jquickcheck.internal.Types;

import com.googlecode.gentyref.GenericTypeReflector;

/**
 * @author dm3
 * 
 * @param <GEN>
 *            type of the generator synthesized by this Synthesizer
 */
public class DefaultSynthesizer<GEN> implements Synthesizer<GEN> {

    private final Map<Class<?>, Synthesized<GEN>> synthesizedGenerators = new HashMap<Class<?>, Synthesized<GEN>>();

    /**
     * Represents a generator which can be synthesized from a set of other generators.
     * 
     * @param <GEN>
     */
    public interface Synthesized<GEN> {
        /**
         * @return type of values generated by the generator produced by this Synthesized
         */
        List<Class<?>> synthesizedFor();

        /**
         * @param components
         *            generators which should be used to create an instance of the generator for this Synthesized
         * @return a generator generating values of type specified in {@code Synthesized#synthesizedFor}.
         */
        GEN synthesize(List<GEN> components);
    }

    /**
     * If a subclass of this Synthesized is given to the Synthesizer, all of the super interfaces of the <tt>Class</tt>
     * which represents the value generated by the generators synthesized by this Synthesized will be synthesizable by
     * the Synthesizer.
     * <p>
     * E-mail me if you understood the sentence above.
     * 
     * @param <GEN>
     */
    public abstract static class AbstractSynthesized<GEN> implements Synthesized<GEN> {

        protected final Class<?> clazz;

        protected AbstractSynthesized(Class<?> clazz) {
            this.clazz = clazz;
        }

        @Override
        public List<Class<?>> synthesizedFor() {
            List<Class<?>> result = new ArrayList<Class<?>>();
            result.add(clazz);
            result.addAll(Types.allParameterizedSuperTypesOf(clazz));
            return result;
        }

        @Override
        public String toString() {
            return String.format("Synthesized for %s and superclasses", clazz);
        }
    }

    public DefaultSynthesizer(Iterable<Synthesized<GEN>> synthesizeds) {
        for (Synthesized<GEN> s : synthesizeds) {
            for (Class<?> clazz : s.synthesizedFor()) {
                if (!synthesizedGenerators.containsKey(clazz)) {
                    synthesizedGenerators.put(clazz, s);
                }
            }
        }
    }

    @Override
    public GEN synthesize(Type t, List<GEN> components) {
        validate(t, components);

        Class<?> clazz = GenericTypeReflector.erase(t);
        if (synthesizedGenerators.containsKey(clazz)) {
            return synthesizedGenerators.get(clazz).synthesize(components);
        }
        throw new QuickCheckException("Could not find a synthesizer for class: " + clazz + " in " + this);
    }

    private void validate(Type t, List<GEN> components) {
        if (Types.hasTypeArguments(t) && t instanceof ParameterizedType) {
            if (((ParameterizedType) t).getActualTypeArguments().length != components.size()) {
                throw notEnoughGeneratorsFor(t, components);
            }
        } else if (Arrays.isArray(t) && components.size() != 1) {
            throw notEnoughGeneratorsFor(t, components);
        }
    }

    private IllegalArgumentException notEnoughGeneratorsFor(Type t, List<GEN> components) {
        return new IllegalArgumentException(String.format(
                "Not enough generators (%s) provided to synthesize type: %s", components, t));
    }

    @Override
    public String toString() {
        return "Synthesizer: " + synthesizedGenerators.toString();
    }

}
