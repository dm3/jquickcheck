## Features DONE
* [Junit integration] Generator instances in @Before and @BeforeClass blocks

    *Result*

    Generators cannot be initialized in Before blocks in JUnit as Befores are
    applied to the Statement after it's generated by jcheck. This isn't
    impossible, just requires more work.

* [Generator API] - what we have in fj-test currently won't work as it's not really extensible
    * Use quickcheck from quickcheck.java.net
    * Ideally specifying generators should look like this:

        @Arb
        Generator<Integer> sizedInt = of(integer(), from(1), to(10))

        @Arb
        Generator<List<String>> listOfStrings = list(of(string(), alphanumeric()))

    *Result*

    This feature won't be implemented as jcheck relies on FJ/javaNetQuickCheck generators.

* Separate the project into 5 submodules:
    - JUnit
    - TestNG
    - FJ
    - java.net.QuickCheck
    - core

    *Result*

    Actually separated into even more very thin submodules

* FJ - allow both Gen and Arbitrary as generators?

    *Result*

    Only Arbitrary. Supporting both is just a lot more work for no gain.

* Automatic generator resolution according to types. Sensible defaults and generator registry.

* Add default generator resolution strategy discovery

* Test project which will use quickcheck and codemodel to generate test classes and feed them back into jquickcheck.

    *Result*

    Wanted to use codemodel at first, but found out it's GPL'd. This wouldn't
    cause much trouble as it would only be used for testing purposes (no
    linking with codemodel in the released jars) but it would make the
    `jquickcheck-test` project GPL which doesn't really suit me.
    Not sure if this brought any advantages. Had fun exploring javassist anyway.
    NOTE: javassist doesn't support generics - patches? Fluent interface for class building?

* strict mode: by default should be set to true. When true, no default generators should be used to satisfy properties.

## Features TODO
* Default generator resolution for Collections/Arrays

    Generators (lets say they have type G) can be acquired from:
    * Fields of type G declared in the test case
        Requirements:
        - either field declaration must be parameterized by a type which is generated by this generator
        - or the generator type must retain the type parameter which is the type of values generated by this generator
    Valid declarations: `G<Integer> intGen = G.integers();`, `G intGen = new G<Integer>() { ... }`
    Invalid declarations: `G intGen = G.integers();` where `G.integers `returns `new G() { ... }`
    * Set of default generators:
        Default generators are specified separately for each quickcheck
        provider. They are composed of all non-parameterized types and arrays.
        Default generators can be turned on a test case/test method/method
        parameter basis by settings `useDefaults = true`.
    * Synthetic generators:
        Synthetic generators are generators of types parameterized by type
        parameters, such as `List`, `Iterable` or `Map`. These generators are
        specified for each quickcheck provider separately. They are turned on
        by setting `useSynthetic = true`. If `useDefaults` is also set to true,
        you will be able to automatically generate synthetic generators for
        default generators, for example, `List<int[]>`.  Synthetic generators
        can also be applied recursively on themselves, so, by enabling
        synthetic generators you will be able to automatically generate
        arguments of nested container types, for example,
        `Iterable<Iterable<Integer>>`.

* Additional custom generator type resolution algorithms for javaNetQuickCheck and FJ (based on method return type?)

* Integration with templates (makeiteasy):

    FJ: Some code generation will probably be needed to generate the Gen for
    the result of the template.  All of the properties registered with `with`
    will have to be associated to some static registry and later, when the test
    method is executed, will be bound (`Gen#bind`) to produce the
    `Gen<Result>`.

* Dependencies between tests (ala JExample/jBehave/TestNG)
