## Features DONE
* [Junit integration] Generator instances in @Before and @BeforeClass blocks

    *Result*

    Generators cannot be initialized in Before blocks in JUnit as Befores are
    applied to the Statement after it's generated by jcheck. This isn't
    impossible, just requires more work.

* [Generator API] - what we have in fj-test currently won't work as it's not really extensible
    * Use quickcheck from quickcheck.java.net
    * Ideally specifying generators should look like this:

        @Arb
        Generator<Integer> sizedInt = of(integer(), from(1), to(10))

        @Arb
        Generator<List<String>> listOfStrings = list(of(string(), alphanumeric()))

    *Result*

    This feature won't be implemented as jcheck relies on FJ/javaNetQuickCheck generators.

* Separate the project into 5 submodules:
    - JUnit
    - TestNG
    - FJ
    - java.net.QuickCheck
    - core

    *Result*

    Actually separated into even more very thin submodules

* FJ - allow both Gen and Arbitrary as generators?

    *Result*

    Only Arbitrary. Supporting both is just a lot more work for no gain.

* Automatic generator resolution according to types. Sensible defaults and generator registry.

* Add default generator resolution strategy discovery

* Test project which will use quickcheck and codemodel to generate test classes and feed them back into jquickcheck.

    *Result*

    Wanted to use codemodel at first, but found out it's GPL'd. This wouldn't
    cause much trouble as it would only be used for testing purposes (no
    linking with codemodel in the released jars) but it would make the
    `jquickcheck-test` project GPL which doesn't really suit me.
    Not sure if this brought any advantages. Had fun exploring javassist anyway.
    NOTE: javassist doesn't support generics - patches? Fluent interface for class building?

* strict mode: by default should be set to true. When true, no default generators should be used to satisfy properties.

* Default generator resolution for Collections/Arrays

    Generators (lets say they have type G) can be acquired from:

    * Fields of type G declared in the test case
        Requirements:
        - either field declaration must be parameterized by a type which is generated by this generator
        - or the generator type must retain the type parameter which is the type of values generated by this generator

    Valid declarations: `G<Integer> intGen = G.integers();`, `G intGen = new G<Integer>() { ... }`
    Invalid declarations: `G intGen = G.integers();` where `G.integers `returns `new G() { ... }`

    * Set of default generators:
        Default generators are specified separately for each quickcheck
        provider. They are composed of all non-parameterized types.  Default
        generators can be turned on a test case/test method/method parameter
        basis by settings `useDefaults = true`.
    * Synthetic generators:
        Synthetic generators are generators of types parameterized by type
        parameters, such as `List`, `Iterable`, `Map` or other containers, such
        as `Arrays`. These generators are specified for each quickcheck
        provider separately. They are turned on by setting `useSynthetic =
        true`. If `useDefaults` is also set to true, you will be able to
        automatically generate synthetic generators for default generators, for
        example, `List<Integer>`.  Synthetic generators can also be applied
        recursively on themselves, so, by enabling synthetic generators you
        will be able to automatically generate arguments of nested container
        types, for example, `Iterable<Iterable<Integer>>`.

    *Result*

    Core framework for synthetic generators

* Synthetic/default generators for FJ

* Implicit generators

## Features TODO

* "Role" based accessibility to generators with different roles (defaults, synthetics, custom groups)

* Synthetic/default generators for QC

* Replace @Disabled with testing framework specific annotation (@Ignore in JUnit)

* Additional custom generator type resolution algorithms for javaNetQuickCheck and FJ (based on method return type?)

* Integration with templates (makeiteasy):

    FJ: Some code generation will probably be needed to generate the Gen for
    the result of the template.  All of the properties registered with `with`
    will have to be associated to some static registry and later, when the test
    method is executed, will be bound (`Gen#bind`) to produce the
    `Gen<Result>`.

* Dependencies between tests (ala JExample/jBehave/TestNG)
