## Features DONE
1. Generator instances in @Before and @BeforeClass blocks
    - Generators cannot be initialized in Before blocks in JUnit as Befores are
      applied to the Statement after it's generated by jcheck. This isn't
      impossible, just requires more work.
2. Generator API - what we have in fj-test currently won't work as it's not really extensible
    * Use quickcheck from quickcheck.java.net
    * Ideally specifying generators should look like this:

    @Arb
    Generator<Integer> sizedInt = of(integer(), from(1), to(10))

    @Arb
    Generator<List<String>> listOfStrings = list(of(string(), alphanumeric()))

This feature won't be implemented as jcheck relies on FJ/javaNetQuickCheck generators.
3. Separate the project into 5 submodules:
    - JUnit
    - TestNG
    - FJ
    - java.net.QuickCheck
    - core
Actually separated into even more very thin submodules
7. FJ - allow both Gen and Arbitrary as generators?
Only Arbitrary
4. Automatic generator resolution according to types. Sensible defaults and generator registry.
6. Add default generator resolution strategy discovery
10. Test project which will use quickcheck and codemodel to generate test classes and feed them back into jquickcheck.
    Wanted to use codemodel at first, but found out it's GPL'd. This wouldn't
    cause much trouble as it would only be used for testing purposes (no
    linking with codemodel in the released jars) but it would make the
    `jquickcheck-test` project GPL which doesn't really suit me.
Not sure if this brought any advantages. Had fun exploring javassist anyway.
NOTE: javassist doesn't support generics - patches? Fluent interface for class building?
11. strict mode: by default should be set to true. When true, no default
    generators should be used to satisfy properties.

## Features TODO
12. Default generator resolution for Collections/Arrays
Generators (lets say they have type G) can be acquired from:
* Fields of type G declared in the test case
    Requirements:
    - either field declaration must be parameterized by a type which is generated by this generator
    - or the generator type must retain the type parameter which is the type of values generated by this generator
Valid declarations: `G<Integer> intGen = G.integers();`, `G intGen = new G<Integer>() { ... }`
Invalid declarations: `G intGen = G.integers();` where `G.integers `returns `new G() { ... }`
* Set of default generators:
    Default generators are specified separately for each quickcheck provider. They are composed of all non-parameterized types and arrays.
    Default generators can be turned on a test case/test method/method parameter basis by settings `useDefaults = true`.
* Synthetic generators:
    Synthetic generators are generators of types parameterized by type parameters, such as `List`, `Iterable` or `Map`. These generators
    are specified for each quickcheck provider separately. They are turned on by setting `useSynthetic = true`. If `useDefaults` is also
    set to true, you will be able to automatically generate synthetic generators for default generators, for example, `List<int[]>`.
    Synthetic generators can also be applied recursively on themselves, so, by enabling synthetic generators you will be able to automatically
    generate arguments of nested container types, for example, `Iterable<Iterable<Integer>>`.

8. Additional custom generator type resolution algorithms for javaNetQuickCheck and FJ (based on method return type?)
9. Integration with templates (makeiteasy):
    - FJ: Some code generation will probably be needed to generate the Gen for the result of the template.
          All of the properties registered with `with` will have to be associated to some static registry and later,
          when the test method is executed, will be bound (`Gen#bind`) to produce the `Gen<Result>`.
3. Dependencies between tests (ala JExample/jBehave/TestNG)
